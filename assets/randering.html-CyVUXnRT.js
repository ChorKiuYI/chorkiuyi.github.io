import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,e as i}from"./app-qKmLr34n.js";const n="/assets/image-Ct2whnlY.png",r="/assets/image-1-CTu8dJHu.png",s="/assets/image-2-CDhIlc-J.png",l="/assets/image-3-B1FjIaJm.png",o="/assets/image-5-DRRNcCb0.png",p="/assets/image-6-DSth2gMB.png",g="/assets/image-7-Cx7Cn_jK.png",c="/assets/image-8-DwjL3tkT.png",d="/assets/image-9-5_d2juCe.png",m="/assets/image-10-DNiCAw-o.png",f="/assets/image-11-BqrruwIj.png",h="/assets/image-12-Cz4uaDlg.png",x="/assets/image-13-BcqKeR4h.png",_="/assets/image-14-DAc2oK0R.png",u="/assets/image-15-sQhpXD97.png",y="/assets/image-16-C_X4EmHR.png",A="/assets/image-17-BCPf1d_i.png",b="/assets/image-18-CR1CUkES.png",S="/assets/image-19-DNU1LU3f.png",z="/assets/image-20-CiCA-fu4.png",C="/assets/image-21-CpNmi4eH.png",M="/assets/image-22-DL61eIMd.png",w="/assets/image-23-B3gulWMs.png",D="/assets/image-24-CXAAtYny.png",L="/assets/image-25-BnKe04RC.png",H="/assets/image-26-C27EshYq.png",k="/assets/image-27-OZ4HkyCF.png",T="/assets/image-28-DtVTtxSS.png",O="/assets/image-29-BHXCaaaN.png",J="/assets/image-30-y8z4j8W-.png",v={},P=i('<p>渲染 （rander）</p><p><strong>html字符串 ——渲染——&gt; 像素信息</strong></p><figure><img src="'+n+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><figure><img src="'+r+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><figure><img src="'+s+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h2 id="浏览器是如何渲染页面的" tabindex="-1"><a class="header-anchor" href="#浏览器是如何渲染页面的"><span>浏览器是如何渲染页面的？</span></a></h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个<strong>渲染任务</strong>，并将其传递给<strong>渲染主线程的消息队列</strong>。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><p>整个渲染流程分为多个阶段，分别是:HTML 解析、样式计算、布局、分层、绘制、分块、光棚化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><h3 id="_1、解析-html-parse-html" tabindex="-1"><a class="header-anchor" href="#_1、解析-html-parse-html"><span>1、<em>解析 HTML（Parse HTML）</em></span></a></h3><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，<strong>率先下载HTML中的外部CSS 文件和 外部的JS 文件</strong>。</p><p><strong>如果主线程解析到 <code>link </code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是CSS 不会阻塞 HTML 解析的根本原因。</strong></p><p>如果主线程解析到 <code>script</code> 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是<strong>因为JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停</strong>。这就是 JS 会阻塞 HTML解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM 树中。</p><p><img src="'+l+'" alt="Alt text" loading="lazy"><img src="'+o+'" alt="Alt text" loading="lazy"><img src="'+p+'" alt="Alt text" loading="lazy"><img src="'+g+'" alt="Alt text" loading="lazy"><img src="'+c+'" alt="Alt text" loading="lazy"></p><h4 id="常见问题-html-解析过程中遇到-css-代码怎么办" tabindex="-1"><a class="header-anchor" href="#常见问题-html-解析过程中遇到-css-代码怎么办"><span>常见问题：HTML 解析过程中遇到 CSS 代码怎么办？</span></a></h4><p>为了提⾼解析效率，浏览器会启动⼀个预解析器率先下载和解析 CSS</p><figure><img src="'+d+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="常见问题-html-解析过程中遇到-js-代码怎么办" tabindex="-1"><a class="header-anchor" href="#常见问题-html-解析过程中遇到-js-代码怎么办"><span>常见问题：HTML 解析过程中遇到 JS 代码怎么办？</span></a></h4><p>渲染主线程遇到 JS 时必须暂停⼀切⾏为，等待下载执⾏完后才能继续 预解析线程可以分担⼀点下载 JS 的任务</p><p><img src="'+m+'" alt="Alt text" loading="lazy"> 最终</p><figure><img src="'+f+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="_2、样式计算-recalculate-style" tabindex="-1"><a class="header-anchor" href="#_2、样式计算-recalculate-style"><span>2、<em>样式计算（Recalculate Style）</em></span></a></h3><p>主线程会遍历得到的DOM树，依次为树中的每个节点计算出它最终的样式，称之为Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>;相对单位会变成绝对单位，比如<code>em</code>变成<code>px</code>。</p><p>这一步完成后，会得到一颗带有样式的DOM树。</p><figure><img src="'+h+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="_3、布局-layout-布局完成后会得到布局树" tabindex="-1"><a class="header-anchor" href="#_3、布局-layout-布局完成后会得到布局树"><span>3、<em>布局（Layout）</em>，布局完成后会得到布局树</span></a></h3><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p><strong>大部分时候，DOM 树和布局树并非一一对应</strong></p><p>比如<code> display:none</code> 的节点没有几何信息，因此不会生成到布局树;又比如使用了<code>伪元素选择器</code>（例如<code>::before</code>、<code>::after</code>、<code>::first-child</code>），虽然 DOM树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 <img src="'+x+'" alt="Alt text" loading="lazy"></p><p>DOM 树 和 Layout 树不⼀定是⼀⼀对应的</p><figure><img src="'+_+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>DOM 树 和 Layout 树不⼀定是⼀⼀对应的</p><figure><img src="'+u+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>DOM 树 和 Layout 树不⼀定是⼀⼀对应的</p><figure><img src="'+y+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="_4、分层-layer" tabindex="-1"><a class="header-anchor" href="#_4、分层-layer"><span>4、<em>分层（Layer）</em></span></a></h3><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p><code>滚动条、堆叠上下文、transform、opacity</code> 等样式都会或多或少的影响分层结果，也可以通过 <code>will-change</code> 属性更大程度的影响分层结果。</p><figure><img src="'+A+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><figure><img src="'+b+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="_5、绘制-paint" tabindex="-1"><a class="header-anchor" href="#_5、绘制-paint"><span>5、<em>绘制（Paint）</em></span></a></h3><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><p>这⾥的绘制，是为每⼀层⽣成如何绘制的指令</p><figure><img src="'+S+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>渲染主线程的⼯作到此为⽌，剩余步骤交给其他线程完成</p><figure><img src="'+z+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><blockquote><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p></blockquote><p>分块会将每⼀层分为多个⼩的区域</p><figure><img src="'+C+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>分块的⼯作是交给多个线程同时进⾏的</p><figure><img src="'+M+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="_6、光栅化阶段-raster-。" tabindex="-1"><a class="header-anchor" href="#_6、光栅化阶段-raster-。"><span>6、<em>光栅化阶段（Raster）</em>。</span></a></h3><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且<strong>优先处理靠近视口区域的块</strong>，</p><p>光栅化的结果，就是一块一块的位图</p><figure><img src="'+w+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><figure><img src="'+D+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="_7、画-draw" tabindex="-1"><a class="header-anchor" href="#_7、画-draw"><span>7、<em>画（Draw）</em></span></a></h3><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引(quad)」信息。</p><figure><img src="'+L+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><figure><img src="'+H+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>**指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像**</p><h1 id="补充问题" tabindex="-1"><a class="header-anchor" href="#补充问题"><span>补充问题：</span></a></h1><h2 id="什么是reflow" tabindex="-1"><a class="header-anchor" href="#什么是reflow"><span>什么是reflow？</span></a></h2><figure><img src="'+k+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>reflow 的本质就是<strong>重新计算 layout 树</strong>。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即reflow。</p><h2 id="什么是-repaint" tabindex="-1"><a class="header-anchor" href="#什么是-repaint"><span>什么是 repaint?</span></a></h2><figure><img src="'+T+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>repaint 的本质就是<strong>重新根据分层信息计算了绘制指令</strong>。</p><p>当改动了可见样式后，就需要重新计算，会引发repaint。</p><p>由于元素的布局信息也属于可见样式，所以<strong>reflow 一定会引起repaint</strong>。</p><h2 id="为什么-transform-的效率高" tabindex="-1"><a class="header-anchor" href="#为什么-transform-的效率高"><span>为什么 transform 的效率高?</span></a></h2><figure><img src="'+O+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>因为 transform 既不会影响布局也不会影响绘制指令，它<strong>影响的只是渲染流程的最后一个「draw」阶段</strong></p><figure><img src="'+J+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响演染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>',87),R=[P];function j(B,U){return e(),a("div",null,R)}const G=t(v,[["render",j],["__file","randering.html.vue"]]),K=JSON.parse('{"path":"/browser/randering.html","title":"1. 浏览器渲染原理","lang":"en-US","frontmatter":{"title":"1. 浏览器渲染原理","icon":"object-group","order":1,"category":["Guide"],"tag":["浏览器渲染原理"],"description":"渲染 （rander） html字符串 ——渲染——> 像素信息 Alt textAlt text Alt textAlt text Alt textAlt text 浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开...","head":[["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://your.domain/zh/browser/randering.html"}],["meta",{"property":"og:url","content":"https://your.domain/browser/randering.html"}],["meta",{"property":"og:site_name","content":"Docs Demo"}],["meta",{"property":"og:title","content":"1. 浏览器渲染原理"}],["meta",{"property":"og:description","content":"渲染 （rander） html字符串 ——渲染——> 像素信息 Alt textAlt text Alt textAlt text Alt textAlt text 浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:author","content":"ChorKiu"}],["meta",{"property":"article:tag","content":"浏览器渲染原理"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1. 浏览器渲染原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ChorKiu\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"浏览器是如何渲染页面的？","slug":"浏览器是如何渲染页面的","link":"#浏览器是如何渲染页面的","children":[{"level":3,"title":"1、解析 HTML（Parse HTML）","slug":"_1、解析-html-parse-html","link":"#_1、解析-html-parse-html","children":[]},{"level":3,"title":"2、样式计算（Recalculate Style）","slug":"_2、样式计算-recalculate-style","link":"#_2、样式计算-recalculate-style","children":[]},{"level":3,"title":"3、布局（Layout），布局完成后会得到布局树","slug":"_3、布局-layout-布局完成后会得到布局树","link":"#_3、布局-layout-布局完成后会得到布局树","children":[]},{"level":3,"title":"4、分层（Layer）","slug":"_4、分层-layer","link":"#_4、分层-layer","children":[]},{"level":3,"title":"5、绘制（Paint）","slug":"_5、绘制-paint","link":"#_5、绘制-paint","children":[]},{"level":3,"title":"6、光栅化阶段（Raster）。","slug":"_6、光栅化阶段-raster-。","link":"#_6、光栅化阶段-raster-。","children":[]},{"level":3,"title":"7、画（Draw）","slug":"_7、画-draw","link":"#_7、画-draw","children":[]}]},{"level":2,"title":"什么是reflow？","slug":"什么是reflow","link":"#什么是reflow","children":[]},{"level":2,"title":"什么是 repaint?","slug":"什么是-repaint","link":"#什么是-repaint","children":[]},{"level":2,"title":"为什么 transform 的效率高?","slug":"为什么-transform-的效率高","link":"#为什么-transform-的效率高","children":[]}],"git":{},"readingTime":{"minutes":6.22,"words":1867},"filePathRelative":"browser/randering.md","autoDesc":true}');export{G as comp,K as data};
