---
title: 作用域和闭包
icon: circle-info
---

## 前言
### 作用域
JS的作用域主要是**指变量的作用范围**，*可以从大类上分为全局作用域和局部作用域，局部作用域又可以分为函数作用域和块作用域。*

- 全局作用域：作用于所有代码执行的环境（整个script标签内部）或者一个独立的JS文件。在全局作用域声明的变量称为全局变量，它的作用是全局的，即网页里所有的脚本和函数都能访问它。

- 局部作用域：
1. 函数作用域：作用于函数内的代码环境，就是局部作用域，也称为函数作用域。在函数作用域声明的变量称为局部变量，只能在函数内部访问。
2. 块级作用域：由 {} 包括，if、for、while等语句都会生成块作用域。在块作用域声明的变量，只能在块里访问。值得注意的是，在ES5中，JS没有块级作用域的概念，块级作用域是在ES6中新增的。

此外，JS的作用域还有以下特点：
1. JS的作用域是**往下通用的，下层作用域可访问上层作用域的变量，并可修改值**。但如果下层作用域变量和上层同名，下层作用域将覆盖上层变量。
2. 不使用var方法定义的变量，如使用let、const等关键字定义的变量，可能属于全局变量，但不属于window对象的属性，即不能通过window.变量名的方式访问。

总的来说，**正确使用作用域可以使代码更清晰、易懂，减少命名冲突，而且是垃圾回收的基本单元**。

### 闭包
JavaScript中的闭包是指一个内部函数可以访问并操作其外部函数的局部变量、参数和声明的其他内部函数。当这个内部函数在外部函数之外被调用时，它仍然可以访问外部函数的这些变量，即使外部函数已经执行完毕，这些变量也不会被销毁，因为它们被
闭包所引用。

闭包有两个主要特点：
1. 函数嵌套函数：内层函数可以访问外层函数的变量和参数。
2. 变量的持久化：闭包可以防止变量和参数被垃圾回收机制回收，使变量得以持久化。

闭包的作用包括：
1. 间接访问局部变量：提供对局部变量的访问，按需求进行共享和长期保存。
2. 防止变量污染：变量只在闭包内部可访问，防止被外部环境污染。

然而，闭包也有潜在的风险，如果滥用可能导致内存泄漏，因为闭包持有的外部函数变量和参数不会被垃圾回收机制回收，过多的闭包可能导致内存中堆积过多的变量和参数。

闭包的应用非常广泛，例如：
- 实现模块化：通过闭包可以实现JavaScript的模块化，这在开发中非常常用。
- 缓存函数：将函数缓存到外层函数变量中，避免相同的函数被多次调用。
- 封装私有变量：通过闭包获取和设置外层函数的变量，避免变量被外部环境污染。
- 实现函数的柯里化：内层函数使用外层函数的变量和参数，实现柯里化效果。
- 实现防抖和节流：防抖和节流也是通过闭包实现的功能，它们同样涉及到函数嵌套和内层函数使用外层函数的变量和参数。



下面是《你不知道的JS》补充    
# 作用域是什么
## 变量赋值
 变量的赋值操作会执行**两个动作**，首先编译器会在当前作用域中**声明一个变量（**如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它**赋值**。

## 作用域
- 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限
- 作用域是根据名称查找变量的一套规则
- 在javascript中,作用域是变量(对象、函数)的**可访问范围**,是变量在脚本代码中的可读、写的有效范围;作用域可以控制变量的可见性和生命周期。
- “作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用 域以及嵌套的子作用域中根据标识符名称进行变量查找。


## 作用域嵌套
遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

## 作用域链
通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。

小结：
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对 变量进行**赋值**，那么就会使用 **LHS 查询**；如果目的是**获取**变量的值，就会使用 **RHS 查询**。

赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 
2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。


# 词法作用域
## 词法阶段
- 词法作用域就是定义在词法阶段的作用域
换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

### 词法作用域（百度AI解释）
1. 词法作用域，也称为静态作用域，是一种定义变量和函数作用域的方式，它是在编写代码时由代码的结构决定的。12
2. 词法作用域的概念与动态作用域相对，动态作用域是在运行时根据程序的流程信息确定的。在词法作用域中，作用域是在编译阶段（词法解析阶段）确定的，一旦代码编写完成，作用域就已经确定，而不需要等到运行时。
3. 词法作用域的规则是，函数可以访问其自身作用域内的变量以及包含它的上层作用域的变量，这种作用域的查找方式称为词法嵌套。例如，如果一个函数在其上层作用域定义了一个变量，那么这个函数可以访问这个变量，即使它是在不同的位置定义的。
4. 词法作用域的一个特点是，它关注函数在何处声明，而不是从何处调用。这与动态作用域形成对比，动态作用域关注函数从何处调用。
5. 总的来说，词法作用域是一种在编写代码时就已经确定的作用域规则，它有助于在编译阶段就确定变量的访问和作用范围，从而优化代码的执行效率。


### 函数 
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

## 欺骗词法[选看,不推荐使用了解即可]

JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。
- 前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在 运行时）。
- 后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。
- 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。**不要使用它们**。


### eval()方法
定义和用法
- eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。
- 如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。
```js
function foo(str, a) {     
    eval( str ); // 欺骗！    
    console.log( a, b ); 
} 
var b = 2; 
foo( "var b = 3;", 1 );  // 1 3
```
eval(..) 通常被用来执行动态创建的代码
eval(..) 都可以在运行期修改书写期的词法作用域

### with关键字
with 通常被当作重复引用**同一个对象**中的**多个属性**的快捷方式，可以不需要重复引用对象本身
#### 方便访问对象属性
```js
var obj = {
    a: 1,
    b: 2,
    c: 3 
}; 
obj // {a: 1, b: 2, c: 3}
// 简单的快捷方式 
with(obj){
    a="aaa";
    b="bbb";
    c="ccc";
}

obj // {a: 'aaa', b: 'bbb', c: 'ccc'}
```

#### 例子2
```js
function foo(obj) {     
    with (obj) {         
        a = 2;     
    } 
} 
var o1 = {     
    a: 3 
}; 
var o2 = {     
    b: 3 
}; 
foo( o1 ); 
console.log( o1.a ); // 2 
foo( o2 ); 
console.log( o2.a ); // undefined 
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```
with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 **var 声明并不会被限制在这个块的作用域中**，而是被添加到 **with 所处的函数作用域**中

- eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域
- with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。





# 函数作用域和块作用域
## 函数作用域
函数作用域：属于这个函数的全部变量都可以在**整个函数的范围内**使用及复用（事实上在嵌套的作用域中也可以使用）

最小特权原则（又叫最小暴露原则）：这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来。
规避命名冲突

### 基础
我们知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐 藏”起来，外部作用域无法访问包装函数内部的任何内容
```js
var a = 2;  
function foo() { // <-- 添加这一行 
    var a = 3;     
    console.log('里面：'+ a ); // 3 
} // <-- 以及这一行 
foo(); // <-- 以及这一行 
console.log('外面：'+ a ); // 2

// 里面：3
// 外面：2

```
如果函数不需要函数名，并且能够自动运行， 这将会更加理想。
### 方法1

```js
var a = 2;
(function foo(){ // <-- 添加这一行 
    var a = 3;     
    console.log('里面：'+ a ); // 3 
})(); // <-- 以及这一行 
 
console.log('外面：'+ a ); // 2

// 里面：3
// 外面：2

```

对比后总结
- `（function...`函数会被当作函数表达式而不是一个标准的函数声明来处理
- **函数声明**和**函数表达式**之间最重要的区别是它们的名称标识符将会绑定在何处。
- 比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。
- 换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。

### 匿名和具名
#### 匿名具名
函数表达式最熟悉应该是回调函数
```js
// 匿名
setTimeout(function() {     
    console.log("I waited 1 second!"); 
}, 1000 );

// 具名
setTimeout(function timeout() {     
    console.log("I waited 1 second!"); 
}, 1000 );
```
#### 立即执行函数
 `(function(){ .. })()`，函数在一对（）括号里，末尾再加一对括号


```js
var a = 2;  
(function() { 
    var a = 3;     
    console.log( a ); // 3 
})(); 
console.log( a ); // 2
```

## 块级作用域
for if/else with try/catch let const
### let
let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let 为其声明的变量隐式地了所在的块作用域。

```js
var a = 2
if(true){
    var bar1 = a*2
    let bar2 = a*4
}
console.log(`bar1:${bar1}`);// bar1:4
console.log(`bar2:${bar2}`);// bar2 is not defined
```

let循环
`for `循环头部的`let`不仅将`i`绑定到了`for循环`的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

```js
// let变量
for(let i=0;i<3;i++){
    console.log(`i:${i}`);
}
// i:0
// i:1
// i:2
console.log(`外面：${i}`); // i is not defined


// var变量
for(var j=0;j<3;j++){
    console.log(`j:${j}`);
}
console.log(`外面：${j}`);
// j:0
// j:1
// j:2
// 外面：3
```
const可以用来创建常量，和let类似，只是它是常量，不能修改（这里的不能修改主要是存放的指针）,复杂数据类型例如对象、数组是能改里面的数据。如果希望const定义的对象也不能修改的话，使用`Object.freeze()`

```js
if(true){
    const a = 2
    const obj = {
        a:'aa',
        b:'bb'
    }
    a = '123456' // Assignment to constant variable
    obj.a = '123456' // 可以修改

    console.log(a); // 错误
    console.log(obj); // { a: '123456', b: 'bb' } 

    Object.freeze(obj) // 已经冻结了，不能修改
    obj.b = 'bbbbbb'
    console.log(obj) // {a: '123456', b: 'bb'}
}
```
小结：
但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域， 也可以属于某个代码块（通常指 { .. } 内部）。
从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。
在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块 中。


# 变量提升
函数作用域和块作用域的行为是一样的，可以总结为：**任何声明在某个作用域内的变量，都将附属于这个作用域。**

## 引子 
```js
a = 2; 
var a;  
console.log(a); // 2


console.log('打印：'+b) // 打印：undefined
var b = 2 
```
 
`var a = 2` 会分成两个声明。`var a`  和 `a = 2` 第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。

先有声明后有赋值


### 函数变量提升
```js
foo(); 
 
function foo() {        
    console.log( a ); // undefined        
    var a = 2;    
}

```
函数声明会被提升，但是函数表达式却不会被提升
```js
// 函数声明
foo(); 
function foo() {        
    console.log('foo'); // foo 
}
// 函数表达式
foo1() // TypeError
var foo1 = function(){
    console.log('foo1');
}

```
# 作用域闭包

## 什么是闭包
### 词法作用域查找规则
a 是通过普通的词法作用域查找而非闭包被发现的，这里还没有闭包的概念
```js
// 地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，这只是闭包的一部分
function foo() {     
    var a = 2; 
    function bar() {         
        console.log( a ); // 2     
    } 
    bar(); 
} 
foo()

```
### 浅析了解闭包
```js
// 清晰展示闭包作用
function foo() {     
    var a = 2; 
    function bar() {   
        // 函数 bar() 的词法作用域能够访问 foo() 的内部作用域       
        console.log( a );     
    } 
    // 将 bar() 函数本身当作 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值
    return bar; 
} 
var baz = foo(); 
baz(); // 2 —— 朋友，这就是闭包的效果。

```

解释：
- 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 **bar 所引用的函数对象本身当作返回值**。
- 在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。
- **bar()** 显然可以被正常执行。但是在这个例子中，它**在自己定义的词法作用域以外的地方执行**。
- 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。
- 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域？原来是 **bar() 本身在使用**。
- 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。
- **bar() 依然持有对该作用域的引用，而这个引用就叫作闭包**。


**这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的 词法作用域**

```js
function foo() {     
    var a = 2; 
    function baz() {         
        console.log( a ); // 2     
    } 
    bar( baz ); 
} 
function bar(fn) {     
    fn(); // 妈妈快看呀，这就是闭包！ 
}
```
把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部 作用域的闭包就可以观察到了，因为它能够访问 a。

传递函数当然也可以是间接的。
```js
var fn; // 全局变量 
function foo() {     
    var a = 2; 
    function baz() {         
        console.log( a );     
    } 
    fn = baz; // 将 baz 分配给全局变量 
} 
function bar() {     
    fn(); // 妈妈快看呀，这就是闭包！ 
} 
foo(); 
bar(); // 2
```
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。

### 深入闭包

本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！


## 循环和闭包
### for循环
```js
for (var i=1; i<=5; i++) {     
    setTimeout( function timer() {
        console.log( i );     
    }, i*1000 ); 
}
```
### 解决方法

#### IIFE**立即执行函数创建作用域** 【(function(){})()】


```js
// 必须有自己变量
for (var i=1; i<=5; i++) {     
    (function() {         
        var j = i;         
        setTimeout( function timer() {             
            console.log( j );         
            }, j*1000 );     
    })(); 
}

// 上面代码改进后
for (var i=1; i<=5; i++) {     
    (function(i){
        setTimeout( function timer() {
            console.log( i );     
        }, i*1000 ); 
    })(i)
}
``` 

#### 用let创造块级作用域 【let】
```js
for (let i=1; i<=5; i++) {     
    setTimeout( function timer() {         
        console.log( i );     
    }, i*1000 ); 
}

```

## 模块
模块模式需要具备两个必要条件
1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

```js
function CoolModule() {     
    var something = "cool"; 
    var another = [1, 2, 3]; 
 
    function doSomething() {          
        console.log( something );     
    } 
 
    function doAnother() {         
        console.log( another.join( " ! " ) );     
    } 
 
    return {         
        doSomething: doSomething,          
        doAnother: doAnother     
    }; 
} 
 
var foo = CoolModule();  
foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3
```



课外补充：JS不具备动态作用域，只有词法作用域
词法作用域是在**写代码或者说定义时确定的**，而动态作用域是在运行时确定 的。（this 也是！）
词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用

因为词法作用域实在定义时确定的，所以foo函数中的a的值为2，而不是在调用时在bar函数中找到值
```js
function foo() {     
    console.log( a ); 
}  
function bar() {     
    var a = 3;     
    foo(); 
}  
var a = 2; 
bar() // 2

```